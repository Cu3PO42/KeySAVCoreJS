/*!
* KeySAVCoreJS, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
*
* Generated by DuoCode Compiler 1.1.1423.0 [Community]
*/
(function KeySAVCoreJS() {
"use strict";
var $asm = {
    fullName: "KeySAVCoreJS",
    anonymousTypes: [],
    types: [],
    $getAttrs: function() { return [new System.Reflection.AssemblyTitleAttribute.ctor("ClassLibrary"), new System.Reflection.AssemblyDescriptionAttribute.ctor(""), new System.Reflection.AssemblyConfigurationAttribute.ctor(""), new System.Reflection.AssemblyCompanyAttribute.ctor(""), new System.Reflection.AssemblyProductAttribute.ctor("ClassLibrary"), new System.Reflection.AssemblyCopyrightAttribute.ctor("Copyright \xA9  2015"), new System.Reflection.AssemblyTrademarkAttribute.ctor(""), new System.Reflection.AssemblyCultureAttribute.ctor(""), new System.Reflection.AssemblyVersionAttribute.ctor("1.0.0.0"), new System.Reflection.AssemblyFileVersionAttribute.ctor("1.0.0.0"), new DuoCode.Runtime.CompilerAttribute.ctor("1.1.1423.0")]; }
};
var $g = (typeof(global) !== "undefined" ? global : window);
var JS = $g.JS = $g.JS || {};
var KeySAVCore = $g.KeySAVCore = $g.KeySAVCore || {};
KeySAVCore.Structures = KeySAVCore.Structures || {};
KeySAVCore.Exceptions = KeySAVCore.Exceptions || {};
var $d = DuoCode.Runtime;
$d.$assemblies["KeySAVCoreJS"] = $asm;
JS.TypedArray = $d.declare("JS.TypedArray", null, 66, $asm, function($t, $p) {});
JS.Uint8ArrayHelper = $d.declare("JS.Uint8ArrayHelper", System.Object, 0, $asm, function($t, $p) {
    $t.Copy = function Uint8ArrayHelper_Copy(one, offsetOne, two, offsetTwo, length) {
        for (var i = 0; i < length; ++i) {
            two[offsetTwo + i] = one[offsetOne + i];
        }
    };
    $t.Copy$1 = function Uint8ArrayHelper_Copy(one, offsetOne, two, offsetTwo, length) {
        for (var i = 0; i < length; ++i) {
            two[offsetTwo + i] = one[offsetOne + i];
        }
    };
    $t.Empty = function Uint8ArrayHelper_Empty(arr) {
        for (var i = 0; i < arr.length; ++i) {
            if (arr[i] != 0)
                return false;
        }
        return true;
    };
    $t.Empty$1 = function Uint8ArrayHelper_Empty(arr, offset, length) {
        for (var i = offset; i < offset + length; ++i) {
            if (arr[i] != 0)
                return false;
        }
        return true;
    };
    $t.fill = function Uint8ArrayHelper_fill(self, value) {
        for (var i = 0; i < self.length; ++i) {
            self[i] = value;
        }
    };
    $t.fill$1 = function Uint8ArrayHelper_fill(self, value, start, stop) {
        while (start < 0) {
            start += self.length;
        }
        while (stop < 0) {
            stop += self.length;
        }

        for (var i = start; i < stop; ++i) {
            self[i] = value;
        }
    };
});
KeySAVCore.BattleVideoBreaker = $d.declare("KeySAVCore.BattleVideoBreaker", System.Object, 0, $asm, function($t, $p) {
    $t.Load = function BattleVideoBreaker_Load(input, keyGetter, callback) {
        keyGetter(KeySAVCore.BitConverter.ToUInt32(input, 16), KeySAVCore.BitConverter.ToUInt32(input, 
            20), $d.cast(($d.delegate(function(e, key) {
            if (e == null)
                callback(null, new KeySAVCore.BattleVideoReader.ctor(input, key));
            else
                callback(e);
        }, this)), System.Action$2(System.Exception, Uint8Array)));
    };
    $t.Break = function BattleVideoBreaker_Break(video1, video2) {
        var ezeros = KeySAVCore.Structures.PKX.encrypt(new Uint8Array(260));
        var xorstream;
        var breakstream;
        var bvkey = new Uint8Array(4096);

        var result = "";

        //#region Old Exploit to ensure that the usage is correct
        // Validity Check to see what all is participating...

        breakstream = video1.subarray(19992, 21552 /* 0x4E18 + 260 * 6 */);
        // XOR them together at party offset
        xorstream = KeySAVCore.Utility.xor$2(breakstream, 0, video2, 19992, 1560 /* 260*6 */);

        // Retrieve EKX_1's data
        var ekx1 = KeySAVCore.Utility.xor$2(ezeros, 0, xorstream, 260, 260);

        //#endregion
        // If old exploit does not properly decrypt slot1...
        var pkx = KeySAVCore.Structures.PKX.decrypt(ekx1);
        if (!KeySAVCore.Structures.PKX.verifyCHK(pkx)) {
            return new KeySAVCore.Structures.BattleVideoBreakResult.ctor(false, "Improperly set up Battle Videos. Please follow directions and try again", 
                null);
        }

        // Start filling up our key...
        //#region Key Filling (bvkey)
        // Copy in the unique CTR encryption data to ID the video...
        JS.Uint8ArrayHelper.Copy(video1, 16, bvkey, 0, 16);

        // Copy unlocking data
        var key1 = new Uint8Array(260);
        JS.Uint8ArrayHelper.Copy(video1, 19992, key1, 0, 260);
        KeySAVCore.Utility.xor$3(ekx1, 0, key1, 0, bvkey, 256, 260);
        JS.Uint8ArrayHelper.Copy(video1, 20252 /* 0x4E18 + 260 */, bvkey, 516 /* 0x100 + 260 */, 1300 /* 260*5 */); // XORstream from save1 has just keystream.

        // See if Opponent first slot can be decrypted...

        breakstream = video1.subarray(21560, 23120 /* 0x5438 + 260 * 6 */);
        // XOR them together at party offset
        for (var i = 0; i < 1560 /* 260 * 6 */; i++) {
            xorstream[i] = ((breakstream[i] ^ video2[i + 21560]) & 0xFF);
        }
        // XOR through the empty data for the encrypted zero data.
        for (var i = 0; i < 1300 /* 260 * 5 */; i++) {
            bvkey[516 /* 0x100 + 260 */ + i] ^= ezeros[i % 260];
        }

        // Retrieve EKX_2's data
        var ekx2 = KeySAVCore.Utility.xor$2(xorstream, 260, ezeros, 0, 260);
        for (var i = 0; i < 260; i++) {
            xorstream[i] ^= ekx2[i];
        }
        var pkx2 = KeySAVCore.Structures.PKX.decrypt(ekx2);
        if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx2)) && (KeySAVCore.BitConverter.ToUInt16(pkx2, 
            8) != 0)) {
            KeySAVCore.Utility.xor$3(ekx2, 0, video1, 21560, bvkey, 2048, 260);
            JS.Uint8ArrayHelper.Copy(video1, 21820 /* 0x5438 + 260 */, bvkey, 2308 /* 0x800 + 260 */, 
                1300 /* 260 * 5 */); // XORstream from save1 has just keystream.

            for (var i = 0; i < 1300 /* 260 * 5 */; i++) {
                bvkey[2308 /* 0x800 + 260 */ + i] ^= ezeros[i % 260];
            }

            result = "Can dump from Opponent Data on this key too!" + System.Environment().NewLine;
        }
        //#endregion

        var ot = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 176, 24));
        var tid = KeySAVCore.BitConverter.ToUInt16(pkx, 12);
        var sid = KeySAVCore.BitConverter.ToUInt16(pkx, 14);
        var tsv = (((tid ^ sid) >> 4) & 0xFFFF);
        // Finished, allow dumping of breakstream
        result += String.Format("Success!\nYour first Pokemon's TSV: {0}\nOT: {1}\n\nPlease save your keystream.", 
            $d.array(System.Object, [tsv.ToString$1("D4"), ot]));

        return new KeySAVCore.Structures.BattleVideoBreakResult.ctor(true, result, bvkey);
    };
});
KeySAVCore.Structures.BattleVideoBreakResult = $d.declare("KeySAVCore.Structures.BattleVideoBreakResult", System.Object, 0, $asm, function($t, $p) {
    $t.$ator = function() {
        this.success = false;
        this.result = null;
        this.key = null;
    };
    $t.ctor = function BattleVideoBreakResult(success, result, key) {
        $t.$baseType.ctor.call(this);
        this.success = success;
        this.result = result;
        this.key = key;
    };
    $t.ctor.prototype = $p;
});
KeySAVCore.BattleVideoReader = $d.declare("KeySAVCore.BattleVideoReader", System.Object, 0, $asm, function($t, $p) {
    $t.cctor = function() {
        $t.offset = 19992;
        $t.keyoff = 256;
    };
    $t.$ator = function() {
        this.video = null;
        this.key = null;
    };
    $t.ctor = function BattleVideoReader(file, key_) {
        $t.$baseType.ctor.call(this);
        this.video = file;
        this.key = key_;
    };
    $t.ctor.prototype = $p;
    $p.getPkx = function BattleVideoReader_getPkx(slot, opponent) {
        var ekx;
        var pkx;
        var opponent_ = opponent ? 1 : 0;
        ekx = KeySAVCore.Utility.xor$2(this.video, 19992 /* BattleVideoReader.offset */ + 260 * slot + opponent_ * 1568, 
            this.key, 256 /* BattleVideoReader.keyoff */ + 260 * slot + opponent_ * 1792, 260);
        pkx = KeySAVCore.Structures.PKX.decrypt(ekx);
        if (JS.Uint8ArrayHelper.Empty(pkx)) {
            return null;
        }
        return new KeySAVCore.Structures.PKX.ctor$1(KeySAVCore.Structures.PKX.verifyCHK(pkx) ? pkx : ekx, 
            -1, slot, false);
    };
    $p.get_DumpsEnemy = function BattleVideoReader_get_DumpsEnemy() {
        return (KeySAVCore.BitConverter.ToUInt32(this.key, 2048) | KeySAVCore.BitConverter.ToUInt32(this.key, 
            2052)) != 0;
    };
});
KeySAVCore.BitConverter = $d.declare("KeySAVCore.BitConverter", System.Object, 0, $asm, function($t, $p) {
    $t.ctor = function BitConverter() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
    $t.ToUInt16$2 = function BitConverter_ToUInt16(array, pos) {
        return ((array[pos] | array[pos + 1] << 8) & 0xFFFF);
    };
    $t.ToUInt16$1 = function BitConverter_ToUInt16(array, pos) {
        return $t.ToUInt16$2(array, pos);
    };
    $t.ToUInt16 = function BitConverter_ToUInt16(array, pos) {
        return ((array[pos] | array[pos + 1] << 8) & 0xFFFF);
    };
    $t.ToUInt32$1 = function BitConverter_ToUInt32(arr, pos) {
        return $d.toUInt32((arr[pos] | arr[pos + 1] << 8 | arr[pos + 2] << 16 | arr[pos + 3] << 24));
    };
    $t.ToInt32$1 = function BitConverter_ToInt32(arr, pos) {
        return arr[pos] | arr[pos + 1] << 8 | arr[pos + 2] << 16 | arr[pos + 3] << 24;
    };
    $t.ToUInt32 = function BitConverter_ToUInt32(arr, pos) {
        return $d.toUInt32((arr[pos] | arr[pos + 1] << 8 | arr[pos + 2] << 16 | arr[pos + 3] << 24));
    };
    $t.ToInt32 = function BitConverter_ToInt32(arr, pos) {
        return arr[pos] | arr[pos + 1] << 8 | arr[pos + 2] << 16 | arr[pos + 3] << 24;
    };
    $t.GetBytes$2 = function BitConverter_GetBytes(val) {
        var res = $d.array(System.Byte, [((val & 255) & 0xFF), ((val >> 8) & 0xFF)]);
        return res;
    };
    $t.GetBytes = function BitConverter_GetBytes(val) {
        var res = $d.array(System.Byte, [((val & 255) & 0xFF), (((val >> 8) & 255) & 0xFF), (((val >> 16) & 255) & 0xFF), 
            (((val >> 24) & 255) & 0xFF)]);
        return res;
    };
    $t.GetBytes$1 = function BitConverter_GetBytes(val) {
        var res = $d.array(System.Byte, [((val & 255) & 0xFF), (((val >> 8) & 255) & 0xFF), (((val >> 16) & 255) & 0xFF), 
            (((val >> 24) & 255) & 0xFF)]);
        return res;
    };
});
KeySAVCore.Convert = $d.declare("KeySAVCore.Convert", System.Object, 0, $asm, function($t, $p) {
    $t.ctor = function Convert() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
    $t.ToBoolean = function Convert_ToBoolean(val) {
        return val != 0;
    };
});
KeySAVCore.Exceptions.NoKeyException = $d.declare("KeySAVCore.Exceptions.NoKeyException", System.Exception, 0, $asm, function($t, $p) {
    $t.ctor = function NoKeyException() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
});
KeySAVCore.Exceptions.NoSaveException = $d.declare("KeySAVCore.Exceptions.NoSaveException", System.Exception, 0, $asm, function($t, $p) {
    $t.ctor = function NoSaveException() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
});
KeySAVCore.Exceptions.NoBattleVideoException = $d.declare("KeySAVCore.Exceptions.NoBattleVideoException", System.Exception, 0, $asm, function($t, $p) {
    $t.ctor = function NoBattleVideoException() {
        $t.$baseType.ctor.call(this);
    };
    $t.ctor.prototype = $p;
});
KeySAVCore.ISaveReader = $d.declare("KeySAVCore.ISaveReader", null, 66, $asm, function($t, $p) {});
KeySAVCore.Structures.PKX = $d.declare("KeySAVCore.Structures.PKX", null, 62, $asm, function($t, $p) {
    $t.ctor = function PKX() {
        this.ec = 0;
        this.pid = 0;
        this.exp = 0;
        this.evHp = 0;
        this.evAtk = 0;
        this.evDef = 0;
        this.evSpAtk = 0;
        this.evSpDef = 0;
        this.evSpe = 0;
        this.ivHp = 0;
        this.ivAtk = 0;
        this.ivDef = 0;
        this.ivSpe = 0;
        this.ivSpAtk = 0;
        this.ivSpDef = 0;
        this.contestStatCool = 0;
        this.contestStatBeauty = 0;
        this.contestStatCute = 0;
        this.contestStatSmart = 0;
        this.contestStatTough = 0;
        this.contestStatSheen = 0;
        this.markings = 0;
        this.hpType = 0;
        this.nickname = null;
        this.notOT = null;
        this.ot = null;
        this.pkrsStrain = 0;
        this.pkrsDuration = 0;
        this.levelMet = 0;
        this.otGender = 0;
        this.isEgg = false;
        this.isNick = false;
        this.isShiny = false;
        this.isGhost = false;
        this.isFatefulEncounter = false;
        this.ability = 0;
        this.abilityNum = 0;
        this.nature = 0;
        this.species = 0;
        this.heldItem = 0;
        this.tid = 0;
        this.sid = 0;
        this.tsv = 0;
        this.esv = 0;
        this.move1 = 0;
        this.move2 = 0;
        this.move3 = 0;
        this.move4 = 0;
        this.move1Pp = 0;
        this.move2Pp = 0;
        this.move3Pp = 0;
        this.move4Pp = 0;
        this.move1Ppu = 0;
        this.move2Ppu = 0;
        this.move3Ppu = 0;
        this.move4Ppu = 0;
        this.eggMove1 = 0;
        this.eggMove2 = 0;
        this.eggMove3 = 0;
        this.eggMove4 = 0;
        this.ribbonSet1 = 0;
        this.ribbonSet2 = 0;
        this.chk = 0;
        this.otFriendship = 0;
        this.otAffection = 0;
        this.eggLocation = 0;
        this.metLocation = 0;
        this.ball = 0;
        this.encounterType = 0;
        this.gameVersion = 0;
        this.countryID = 0;
        this.regionID = 0;
        this.dsregID = 0;
        this.otLang = 0;
        this.box = 0;
        this.slot = 0;
        this.ribbonSet3 = 0;
        this.ribbonSet4 = 0;
        this.form = 0;
        this.gender = 0;
        this.metDate = 0;
        this.eggDate = 0;
        this.data = null;
    };
    $t.ctor.prototype = $p;
    $t.ctor$1 = function PKX(pkx, box, slot, isghost) {
        this.data = ArrayConverter.ToArray(pkx);

        this.box = box;
        this.slot = slot;

        this.isGhost = isghost;

        this.nickname = "";
        this.notOT = "";
        this.ot = "";
        this.ec = KeySAVCore.BitConverter.ToUInt32(pkx, 0);
        this.chk = KeySAVCore.BitConverter.ToUInt16(pkx, 6);
        this.species = KeySAVCore.BitConverter.ToUInt16(pkx, 8);
        this.heldItem = KeySAVCore.BitConverter.ToUInt16(pkx, 10);
        this.tid = KeySAVCore.BitConverter.ToUInt16(pkx, 12);
        this.sid = KeySAVCore.BitConverter.ToUInt16(pkx, 14);
        this.exp = KeySAVCore.BitConverter.ToUInt32(pkx, 16);
        this.ability = pkx[20];
        this.abilityNum = pkx[21];
        // 0x16, 0x17 - unknown
        this.pid = KeySAVCore.BitConverter.ToUInt32(pkx, 24);
        this.nature = pkx[28];
        this.isFatefulEncounter = (pkx[29] & 1) == 1;
        this.gender = (((pkx[29] >> 1) & 3) & 0xFF);
        this.form = ((pkx[29] >> 3) & 0xFF);
        this.evHp = pkx[30];
        this.evAtk = pkx[31];
        this.evDef = pkx[32];
        this.evSpAtk = pkx[34];
        this.evSpDef = pkx[35];
        this.evSpe = pkx[33];
        this.contestStatCool = pkx[36];
        this.contestStatBeauty = pkx[37];
        this.contestStatCute = pkx[38];
        this.contestStatSmart = pkx[39];
        this.contestStatTough = pkx[40];
        this.contestStatSheen = pkx[41];
        this.markings = pkx[42];
        this.pkrsStrain = pkx[43] >> 4;
        this.pkrsDuration = pkx[43] % 16;
        this.ribbonSet1 = KeySAVCore.BitConverter.ToUInt16(pkx, 48);
        this.ribbonSet2 = KeySAVCore.BitConverter.ToUInt16(pkx, 50);
        this.ribbonSet3 = pkx[52];
        this.ribbonSet4 = pkx[53];

        // Block B
        this.nickname = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 64, 24));
        // 0x58, 0x59 - unused
        this.move1 = KeySAVCore.BitConverter.ToUInt16(pkx, 90);
        this.move2 = KeySAVCore.BitConverter.ToUInt16(pkx, 92);
        this.move3 = KeySAVCore.BitConverter.ToUInt16(pkx, 94);
        this.move4 = KeySAVCore.BitConverter.ToUInt16(pkx, 96);
        this.move1Pp = pkx[98];
        this.move2Pp = pkx[99];
        this.move3Pp = pkx[100];
        this.move4Pp = pkx[101];
        this.move1Ppu = pkx[102];
        this.move2Ppu = pkx[103];
        this.move3Ppu = pkx[104];
        this.move4Ppu = pkx[105];
        this.eggMove1 = KeySAVCore.BitConverter.ToUInt16(pkx, 106);
        this.eggMove2 = KeySAVCore.BitConverter.ToUInt16(pkx, 108);
        this.eggMove3 = KeySAVCore.BitConverter.ToUInt16(pkx, 110);
        this.eggMove4 = KeySAVCore.BitConverter.ToUInt16(pkx, 112);

        // 0x72 - Super Training Flag - Passed with pkx to new form

        // 0x73 - unused/unknown
        var IV32 = KeySAVCore.BitConverter.ToUInt32(pkx, 116);
        this.ivHp = IV32 & 31;
        this.ivAtk = (IV32 >> 5) & 31;
        this.ivDef = (IV32 >> 10) & 31;
        this.ivSpe = (IV32 >> 15) & 31;
        this.ivSpAtk = (IV32 >> 20) & 31;
        this.ivSpDef = (IV32 >> 25) & 31;
        this.isEgg = ((IV32 >> 30) & 1) != 0;
        this.isNick = (IV32 >> 31) != 0;

        // Block C
        this.notOT = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 120, 24));
        var notOTG = (pkx[146]) != 0;
        // Memory Editor edits everything else with pkx in a new form

        // Block D
        this.ot = KeySAVCore.Utility.TrimCString(Unicode16LE.GetString(pkx, 176, 24));
        // 0xC8, 0xC9 - unused
        this.otFriendship = pkx[202];
        this.otAffection = pkx[203]; // Handled by Memory Editor
        // 0xCC, 0xCD, 0xCE, 0xCF, 0xD0
        this.eggDate = new Date(pkx[209] + 2000, pkx[210], pkx[211], 0, 0, 0, 0).getTime();
        this.metDate = new Date(pkx[212] + 2000, pkx[213], pkx[214], 0, 0, 0, 0).getTime();
        // 0xD7 - unused
        this.eggLocation = KeySAVCore.BitConverter.ToUInt16(pkx, 216);
        this.metLocation = KeySAVCore.BitConverter.ToUInt16(pkx, 218);
        this.ball = pkx[220];
        this.levelMet = pkx[221] & 127;
        this.otGender = (pkx[221]) >> 7;
        this.encounterType = pkx[222];
        this.gameVersion = pkx[223];
        this.countryID = pkx[224];
        this.regionID = pkx[225];
        this.dsregID = pkx[226];
        this.otLang = pkx[227];

        this.hpType = ((15 * ((this.ivHp & 1) + 2 * (this.ivAtk & 1) + 4 * (this.ivDef & 1) + 8 * (this.ivSpe & 1) + 16 * (this.ivSpAtk & 1) + 32 * (this.ivSpDef & 1))) / 63 | 0) + 1;

        this.tsv = (((this.tid ^ this.sid) >> 4) & 0xFFFF);
        this.esv = (((((this.pid >> 16) & 65535) ^ (this.pid & 65535)) >> 4) & 0xFFFF);

        this.isShiny = (this.tsv == this.esv);
    };
    $t.ctor$1.prototype = $p;
    $t.shuffleArray = function PKX_shuffleArray(pkx, sv) {
        var ekx = new Uint8Array(pkx.length);
        JS.Uint8ArrayHelper.Copy(pkx, 0, ekx, 0, 8);

        // Now to shuffle the blocks

        // Define Shuffle Order Structure
        var aloc = $d.array(System.Byte, [0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 2, 3, 1, 1, 2, 3, 2, 3, 1, 1, 
            2, 3, 2, 3]);
        var bloc = $d.array(System.Byte, [1, 1, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 2, 3, 1, 1, 3, 2, 2, 3, 
            1, 1, 3, 2]);
        var cloc = $d.array(System.Byte, [2, 3, 1, 1, 3, 2, 2, 3, 1, 1, 3, 2, 0, 0, 0, 0, 0, 0, 3, 2, 
            3, 2, 1, 1]);
        var dloc = $d.array(System.Byte, [3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 0, 0, 
            0, 0, 0, 0]);

        // Get Shuffle Order
        var shlog = $d.array(System.Byte, [aloc[sv], bloc[sv], cloc[sv], dloc[sv]]);

        // UnShuffle Away!
        for (var b = 0; b < 4; b++) {
            JS.Uint8ArrayHelper.Copy(pkx, 8 + 56 * shlog[b], ekx, 8 + 56 * b, 56);
        }

        // Fill the Battle Stats back
        if (pkx.length > 232)
            JS.Uint8ArrayHelper.Copy(pkx, 232, ekx, 232, 28);
        return ekx;
    };
    $t.decrypt = function PKX_decrypt(ekx) {
        var pkx = new Uint8Array(232);
        JS.Uint8ArrayHelper.Copy(ekx, 0, pkx, 0, 232);
        var pv = KeySAVCore.BitConverter.ToUInt32(pkx, 0);
        var sv = (((pv & 253952) >> 13) % 24);

        var seed = pv;

        var pkx16 = new Uint16Array(pkx.buffer);
        // Decrypt Blocks with RNG Seed
        for (var i = 4; i < 116 /* 232/2 */; ++i) {
            seed = LCRNG.next(seed);
            pkx16[i] ^= ((seed >> 16) & 0xFFFF);
        }

        // TODO: decrypt party stats?

        // Deshuffle
        pkx = $t.shuffleArray(pkx, sv);
        return pkx;
    };
    $t.encrypt = function PKX_encrypt(pkx) {
        // Shuffle
        var pv = KeySAVCore.BitConverter.ToUInt32(pkx, 0);
        var sv = (((pv & 253952) >> 13) % 24);

        var ekx = new Uint8Array(pkx.length);
        JS.Uint8ArrayHelper.Copy(pkx, 0, ekx, 0, pkx.length);

        // If I unshuffle 11 times, the 12th (decryption) will always decrypt to ABCD.
        // 2 x 3 x 4 = 12 (possible unshuffle loops -> total iterations)
        for (var i = 0; i < 11; i++) {
            ekx = $t.shuffleArray(ekx, sv);
        }

        var seed = pv;
        var ekx16 = new Uint16Array(ekx.buffer);
        // Encrypt Blocks with RNG Seed
        for (var i = 4; i < 116 /* 232/2 */; ++i) {
            seed = LCRNG.next(seed);
            ekx16[i] ^= ((seed >> 16) & 0xFFFF);
        }

        // Encrypt the Party Stats
        seed = pv;
        if (pkx.length > 232)
            for (var i = 116 /* 232/2 */; i < 130 /* 260/2 */; ++i) {
                seed = LCRNG.next(seed);
                ekx16[i] ^= ((seed >> 16) & 0xFFFF);
            }

        // Done
        return ekx;
    };
    $t.verifyCHK = function PKX_verifyCHK(pkx) {
        // TODO refactor, probably pass Uint16Array
        var chk = 0;
        for (var i = 8; i < 232; i += 2) {
            chk += KeySAVCore.BitConverter.ToUInt16(pkx, i);
        }

        var actualsum = KeySAVCore.BitConverter.ToUInt16(pkx, 6);
        if ((KeySAVCore.BitConverter.ToUInt16(pkx, 8) > 750) || (KeySAVCore.BitConverter.ToUInt16(pkx, 
            144) != 0))
            return false;
        return ((chk & 65535) == actualsum);
    };
    $t.getDloc = function PKX_getDloc(ec) {
        // Define Shuffle Order Structure
        var dloc = $d.array(System.Byte, [3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 0, 0, 
            0, 0, 0, 0]);
        var sv = (((ec & 253952) >> 13) % 24);

        return dloc[sv];
    };
});
KeySAVCore.SaveBreaker = $d.declare("KeySAVCore.SaveBreaker", System.Object, 0, $asm, function($t, $p) {
    $t.cctor = function() {
        $t.Magic = 1111835974;
        $t.eggnames = null;
        $t.eggnames = $d.array(String, ["\u30BF\u30DE\u30B4", "Egg", "\u0152uf", "Uovo", "Ei", "", "Huevo", 
            "\uC54C"]);
    };
    $t.Load = function SaveBreaker_Load(input, keyGetter, callback) {
        if (input.length == 1048576) {
            keyGetter(KeySAVCore.BitConverter.ToUInt32(input, 16), KeySAVCore.BitConverter.ToUInt32(input, 
                20), $d.cast(($d.delegate(function(e, key) {
                if (e == null)
                    callback(null, new KeySAVCore.SaveReaderEncrypted.ctor$1(input, key));
                else
                    callback(e);
            }, this)), System.Action$2(System.Exception, KeySAVCore.Structures.SaveKey)));
            return;
        }
        if (input.length == 483328 && KeySAVCore.BitConverter.ToUInt32(input, 482832) == 1111835974 /* SaveBreaker.Magic */) {
            callback(null, new KeySAVCore.SaveReaderDecrypted.ctor(input, "ORAS"));
            return;
        }
        if (input.length == 415232 && KeySAVCore.BitConverter.ToUInt32(input, 414736) == 1111835974 /* SaveBreaker.Magic */) {
            callback(null, new KeySAVCore.SaveReaderDecrypted.ctor(input, "XY"));
            return;
        }
        if (input.length == 222720 /* 232 * 30 * 32 */) {
            callback(null, new KeySAVCore.SaveReaderDecrypted.ctor(input, "YABD"));
            return;
        }
        if (input.length == 215760 /* 232 * 30 * 31 */) {
            callback(null, new KeySAVCore.SaveReaderDecrypted.ctor(input, "PCDATA"));
            return;
        }
        if (input.length == 458752) {
            callback(null, new KeySAVCore.SaveReaderDecrypted.ctor(input, "XYRAM"));
            return;
        }
        if (input.length == 524288) {
            callback(null, new KeySAVCore.SaveReaderDecrypted.ctor(input, "ORASRAM"));
            return;
        }
        throw new KeySAVCore.Exceptions.NoSaveException.ctor();
    };
    $t.Break = function SaveBreaker_Break(break1, break2) {
        var offset = $d.array(System.Int32, 2);
        var empty = new Uint8Array(232);
        var emptyekx = new Uint8Array(232);
        var pkx = new Uint8Array(232);
        var savkey;
        var save1Save;
        savkey = new Uint8Array(740052);
        var result;

        if (!KeySAVCore.Utility.SequenceEqual$2(break1, 16, break2, 16, 8)) {
            return new KeySAVCore.Structures.SaveBreakResult.ctor$1(false, "Saves are not from the same game!\nPlease follow the instructions.", 
                null, null);
        }

        if (KeySAVCore.Utility.SequenceEqual(break1, break2)) {
            return new KeySAVCore.Structures.SaveBreakResult.ctor$1(false, "The saves are identical.\nPlease follow the instructions.", 
                null, null);
        }

        // TODO readd upgrade logic
        if (KeySAVCore.Utility.SequenceEqual$2(break1, 524288, break2, 524288, 520192)) {
            save1Save = break2;
            for (var i = 162304; i < 446160; ++i) {
                break2[i + 520192] = ((break2[i] ^ break1[i] ^ break1[i + 520192]) & 0xFF);
            }
        }
        else
            if (KeySAVCore.Utility.SequenceEqual$2(break1, 4096, break2, 4096, 520192)) {
                save1Save = break1;
            }
            else {
                return new KeySAVCore.Structures.SaveBreakResult.ctor$1(false, "The saves are seperated by more than one save.\nPlease follow the instructions.", 
                    null, null);
            }

        (function() {
            var $ref = { value: break1 };
            var $ref1 = { value: break2 };
            var $result$ = KeySAVCore.Utility.Switch(Uint8Array, $ref, $ref1);
            break1 = $ref.value;
            break2 = $ref1.value;
            return $result$;
        }).call(this);

        //#region Finding the User Specific Data: Using Valid to keep track of progress...
        // Do Break. Let's first do some sanity checking to find out the 2 offsets we're dumping from.
        // Loop through save file to find
        var fo = 682496; // Initial Offset, can tweak later.

        for (var d = 0; d < 2; d++) {
            // Do this twice to get both box offsets.
            for (var i = fo; i <= 757552; i += 68096) {
                var err = 0;
                // Start at findoffset and see if it matches pattern
                if ((break1[i + 4] == break2[i + 4]) && (break1[i + 4 + 232] == break2[i + 4 + 232])) {
                    // Sanity Placeholders are the same
                    for (var j = 0; j < 4; j++) {
                        if (break1[i + j] == break2[i + j])
                            err++;
                    }

                    if (err < 4) {
                        // Keystream ^ PID doesn't match entirely. Keep checking.
                        for (var j = 8; j < 232; j++) {
                            if (break1[i + j] == break2[i + j])
                                err++;
                        }

                        if (err < 20) {
                            // Tolerable amount of difference between offsets. We have a result.
                            offset[d] = i;
                            break;
                        }
                    }
                }
            }
            fo = offset[d] + 6960 /* 232 * 30 */; // Fast forward out of this box to find the next.
        }

        // Now that we have our two box offsets...
        // Check to see if we actually have them.

        if ((offset[0] == 0) || (offset[1] == 0)) {
            // We have a problem. Don't continue.
            result = "Unable to Find Box.\n";
            result += "Keystreams were NOT bruteforced!\n\nStart over and try again :(";
            return new KeySAVCore.Structures.SaveBreakResult.ctor$1(false, result, null, null);
        }
        else {
            // Let's go deeper. We have the two box offsets.
            // Chunk up the base streams.
            var estream1 = new Uint8Array(6960 /* 30 * 232 */);
            var estream2 = new Uint8Array(6960 /* 30 * 232 */);
            // Stuff 'em.
            for (var i = 0; i < 30; i++) {
                for (var j = 0; j < 232; j++) {
                    estream1[i * 232 + j] = break1[offset[0] + 232 * i + j];
                    estream2[i * 232 + j] = break2[offset[1] + 232 * i + j];
                }
            }

            // Okay, now that we have the encrypted streams, formulate our EKX.
            var nick = $t().eggnames[1];
            // Stuff in the nickname to our blank EKX.
            var nicknamebytes = Unicode16LE.GetBytes(nick);
            JS.Uint8ArrayHelper.Copy(nicknamebytes, 0, empty, 64, nicknamebytes.length);

            // Encrypt the Empty PKX to EKX.
            JS.Uint8ArrayHelper.Copy(empty, 0, emptyekx, 0, 232);
            emptyekx = KeySAVCore.Structures.PKX.decrypt(emptyekx);
            // Not gonna bother with the checksum, as this empty file is temporary.

            // Sweet. Now we just have to find the E0-E3 values. Let's get our polluted streams from each.
            // Save file 1 has empty box 1. Save file 2 has empty box 2.
            var pstream1 = new Uint8Array(6960 /* 30 * 232 */); // Polluted Keystream 1
            var pstream2 = new Uint8Array(6960 /* 30 * 232 */); // Polluted Keystream 2
            for (var i = 0; i < 30; i++) {
                for (var j = 0; j < 232; j++) {
                    pstream1[i * 232 + j] = ((estream1[i * 232 + j] ^ emptyekx[j]) & 0xFF);
                    pstream2[i * 232 + j] = ((estream2[i * 232 + j] ^ emptyekx[j]) & 0xFF);
                }
            }

            // Cool. So we have a fairly decent keystream to roll with. We now need to find what the E0-E3 region is.
            // 0x00000000 Encryption Constant has the D block last.
            // We need to make sure our Supplied Encryption Constant Pokemon have the D block somewhere else (Pref in 1 or 3).

            // First, let's get out our polluted EKX's.
            var polekx = $d.array(System.Byte, 6 * 232, [6, 232]);
            for (var i = 0; i < 6; i++) {
                for (var j = 0; j < 232; j++) {
                    polekx[(i) * polekx.$ranks[1] + (j)] = ((break1[offset[1] + 232 * i + j] ^ pstream2[i * 232 + j]) & 0xFF);
                }
            }

            var encryptionconstants = $d.array(System.UInt32, 6); // Array for all 6 Encryption Constants.
            var valid = 0;
            for (var i = 0; i < 6; i++) {
                encryptionconstants[i] = polekx[(i) * polekx.$ranks[1] + 0];
                encryptionconstants[i] += polekx[(i) * polekx.$ranks[1] + 1] * 256;
                encryptionconstants[i] += polekx[(i) * polekx.$ranks[1] + 2] * 65536;
                encryptionconstants[i] += polekx[(i) * polekx.$ranks[1] + 3] * 16777216;
                // EC Obtained. Check to see if Block D is not last.
                if (KeySAVCore.Structures.PKX.getDloc(encryptionconstants[i]) != 3) {
                    valid++;
                    // Find the Origin/Region data.
                    var encryptedekx = new Uint8Array(232);
                    var decryptedpkx = new Uint8Array(232);
                    for (var z = 0; z < 232; z++) {
                        encryptedekx[z] = polekx[(i) * polekx.$ranks[1] + (z)];
                    }

                    decryptedpkx = KeySAVCore.Structures.PKX.decrypt(encryptedekx);

                    // finalize data

                    // Okay, now that we have the encrypted streams, formulate our EKX.
                    nick = $t().eggnames[decryptedpkx[227] - 1];
                    // Stuff in the nickname to our blank EKX.
                    nicknamebytes = Unicode16LE.GetBytes(nick);
                    JS.Uint8ArrayHelper.Copy(nicknamebytes, 0, empty, 64, nicknamebytes.length);

                    // Dump it into our Blank EKX. We have won!
                    empty[224] = decryptedpkx[224];
                    empty[225] = decryptedpkx[225];
                    empty[226] = decryptedpkx[226];
                    empty[227] = decryptedpkx[227];
                    break;
                }
            }
            //#endregion

            if (valid == 0) { // We didn't get any valid EC's where D was not in last. Tell the user to try again with different specimens.
                result = "The 6 supplied Pokemon are not suitable. \nRip new saves with 6 different ones that originated from your save file.\n";
                result += "Keystreams were NOT bruteforced!\n\nStart over and try again :(";
                return new KeySAVCore.Structures.SaveBreakResult.ctor$1(false, result, null, null);
            }
            else {
                //#region Fix up our Empty File
                // We can continue to get our actual keystream.
                // Let's calculate the actual checksum of our empty pkx.
                var empty16 = new Uint16Array(empty.buffer);
                var chk = 0;
                for (var i = 4; i < 116 /* 232 / 2 */; i++) {
                    chk += empty16[i];
                }

                // Apply New Checksum
                empty16[3] = chk;

                // Okay. So we're now fixed with the proper blank PKX. Encrypt it!
                JS.Uint8ArrayHelper.Copy(empty, 0, emptyekx, 0, 232);
                emptyekx = KeySAVCore.Structures.PKX.encrypt(emptyekx);

                // Copy over 0x10-0x1F (Save Encryption Unused Data so we can track data).
                JS.Uint8ArrayHelper.Copy(break1, 16, savkey, 0, 8);
                // Include empty data
                savkey[16] = empty[224];
                savkey[17] = empty[225];
                savkey[18] = empty[226];
                savkey[19] = empty[227];
                // Copy over the scan offsets.
                JS.Uint8ArrayHelper.Copy$1(KeySAVCore.BitConverter.GetBytes(offset[0]), 0, savkey, 28, 
                    4);

                for (var i = 0; i < 30; i++) {
                    for (var j = 0; j < 232; j++) {
                        savkey[256 + i * 232 + j] = ((estream1[i * 232 + j] ^ emptyekx[j]) & 0xFF);
                        savkey[7216 /* 0x100 + (30 * 232) */ + i * 232 + j] = ((estream2[i * 232 + j] ^ emptyekx[j]) & 0xFF);
                    }
                }
                //#endregion
                // Let's extract some of the information now for when we set the Keystream filename.
                //#region Keystream Naming
                var data1 = new Uint8Array(232);
                var data2 = new Uint8Array(232);
                for (var i = 0; i < 232; i++) {
                    data1[i] = ((savkey[256 + i] ^ break1[offset[0] + i]) & 0xFF);
                    data2[i] = ((savkey[256 + i] ^ break2[offset[0] + i]) & 0xFF);
                }
                var data1a = new Uint8Array(232);
                var data2a = new Uint8Array(232);
                JS.Uint8ArrayHelper.Copy(data1, 0, data1a, 0, 232);
                JS.Uint8ArrayHelper.Copy(data2, 0, data2a, 0, 232);
                var pkx1 = KeySAVCore.Structures.PKX.decrypt(data1);
                var pkx2 = KeySAVCore.Structures.PKX.decrypt(data2);
                var chk1 = 0;
                var chk2 = 0;
                for (var i = 8; i < 232; i += 2) {
                    chk1 += KeySAVCore.BitConverter.ToUInt16(pkx1, i);
                    chk2 += KeySAVCore.BitConverter.ToUInt16(pkx2, i);
                }
                if (KeySAVCore.Structures.PKX.verifyCHK(pkx1) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx1, 
                    8))) {
                    // Save 1 has the box1 data
                    pkx = pkx1;
                }
                else
                    if (KeySAVCore.Structures.PKX.verifyCHK(pkx2) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx2, 
                        8))) {
                        // Save 2 has the box1 data
                        pkx = pkx2;
                    }
                    else {
                        // Data isn't decrypting right...
                        for (var i = 0; i < 232; i++) {
                            data1a[i] ^= empty[i];
                            data2a[i] ^= empty[i];
                        }
                        pkx1 = KeySAVCore.Structures.PKX.decrypt(data1a);
                        pkx2 = KeySAVCore.Structures.PKX.decrypt(data2a);
                        if (KeySAVCore.Structures.PKX.verifyCHK(pkx1) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx1, 
                            8))) {
                            // Save 1 has the box1 data
                            pkx = pkx1;
                        }
                        else
                            if (KeySAVCore.Structures.PKX.verifyCHK(pkx2) && KeySAVCore.Convert.ToBoolean(KeySAVCore.BitConverter.ToUInt16(pkx2, 
                                8))) {
                                // Save 2 has the box1 data
                                pkx = pkx2;
                            }
                            else {
                                // Sigh...
                                return new KeySAVCore.Structures.SaveBreakResult.ctor$1(false, "", null, 
                                    null);
                            }
                    }
                //#endregion
            }
        }

        if (true) {
            // Clear the keystream file...
            JS.Uint8ArrayHelper.fill$1(savkey, 0, 256, 216016 /* 0x100+232*30*31 */);
            JS.Uint8ArrayHelper.fill$1(savkey, 0, 262144, 477904 /* 0x40000+232*30*31 */);

            // Copy the key for the slot selector
            JS.Uint8ArrayHelper.Copy(save1Save, 360, savkey, 524288, 4);

            // Copy the key for the other save slot
            KeySAVCore.Utility.xor$3(break2, offset[0], break2, offset[0] - 520192, savkey, 524292, 215760 /* 232*30*31 */);

            // Since we don't know if the user put them in in the wrong order, let's just markup our keystream with data.
            var data1 = new Uint8Array(232);
            var data2 = new Uint8Array(232);
            for (var i = 0; i < 31; i++) {
                for (var j = 0; j < 30; j++) {
                    JS.Uint8ArrayHelper.Copy(break1, offset[0] + i * 6960 /* 232 * 30 */ + j * 232, data1, 
                        0, 232);
                    JS.Uint8ArrayHelper.Copy(break2, offset[0] + i * 6960 /* 232 * 30 */ + j * 232, data2, 
                        0, 232);
                    if (KeySAVCore.Utility.SequenceEqual(data1, data2)) {
                        // Just copy data1 into the key file.
                        JS.Uint8ArrayHelper.Copy(data1, 0, savkey, 256 + i * 6960 /* 232 * 30 */ + j * 232, 
                            232);
                    }
                    else {
                        // Copy both datas into their keystream spots.
                        JS.Uint8ArrayHelper.Copy(data1, 0, savkey, 256 + i * 6960 /* 232 * 30 */ + j * 232, 
                            232);
                        JS.Uint8ArrayHelper.Copy(data2, 0, savkey, 262144 + i * 6960 /* 232 * 30 */ + j * 232, 
                            232);
                    }
                }
            }

            // Save file diff is done, now we're essentially done. Save the keystream.

            // Success
            result = "Keystreams were successfully bruteforced!\n\n";
            result += "Save your keystream now...";
            var tmp = new KeySAVCore.Structures.SaveKey.ctor$1(savkey);
            return new KeySAVCore.Structures.SaveBreakResult.ctor$1(true, result, tmp, pkx);
        }
    };
});
KeySAVCore.Structures.SaveBreakResult = $d.declare("KeySAVCore.Structures.SaveBreakResult", null, 62, $asm, function($t, $p) {
    $t.ctor = function SaveBreakResult() {
        this.success = false;
        this.result = null;
        this.resPkx = null;
        this.key = null;
    };
    $t.ctor.prototype = $p;
    $t.ctor$1 = function SaveBreakResult(success, result, key, resPkx) {
        this.success = success;
        this.result = result;
        this.key = key;
        this.resPkx = resPkx;
    };
    $t.ctor$1.prototype = $p;
});
KeySAVCore.Structures.SaveKey = $d.declare("KeySAVCore.Structures.SaveKey", null, 62, $asm, function($t, $p) {
    $t.ctor = function SaveKey() {
        this.keyData = null;
        this.stamp1 = 0;
        this.stamp2 = 0;
        this.location = null;
        this.boxOffset = 0;
        this.boxKey1 = null;
        this.blank = null;
        this.slotsUnlocked = null;
        this.boxKey2 = null;
        this.slot1Flag = 0;
        this.slot1Key = null;
        this.magic = 0;
    };
    $t.ctor.prototype = $p;
    $t.ctor$1 = function SaveKey(key) {
        this.keyData = key;
        var key32 = new Uint32Array(key.buffer, key.byteOffset, 185013);
        this.stamp1 = key32[0];
        this.stamp2 = key32[1];
        this.magic = key32[2];
        this.location = key.subarray(16, 20);
        this.boxOffset = key32[7 /* 0x1C / 4 */];
        this.boxKey1 = key.subarray(256, 216016);
        this.blank = key.subarray(216016, 216248 /* 0x34BD0 + 0xE8 */);
        this.slotsUnlocked = key.subarray(216248, 217178 /* 0x34CB8 + 0x3A2 */);
        this.boxKey2 = key.subarray(262144, 477904 /* 0x40000 + 0x34AD0 */);
        this.slot1Flag = key32[131072 /* 0x80000 / 4 */];
        this.slot1Key = key.subarray(524292, 740052 /* 0x80004 + 0x34AD0 */);
        if (this.magic != 1111835974) {
            this.magic = 1111835974;
            key32[2] = this.magic;
            JS.Uint8ArrayHelper.fill(this.blank, 0);
            JS.Uint8ArrayHelper.Copy(this.location, 0, this.blank, 224, 4);
            var nicknamebytes = Unicode16LE.GetBytes(KeySAVCore.SaveBreaker().eggnames[this.blank[227] - 1]);
            JS.Uint8ArrayHelper.Copy(nicknamebytes, 0, this.blank, 64, nicknamebytes.length > 24 ? 24 : nicknamebytes.length);

            var blank16 = new Uint16Array(this.blank.buffer, this.blank.byteOffset, 116 /* 0xE8/2 */);
            var chk = 0;
            for (var i = 4; i < 116 /* 232/2 */; i++) {
                chk += blank16[i];
            }

            blank16[3] = chk;
            JS.Uint8ArrayHelper.Copy(KeySAVCore.Structures.PKX.encrypt(this.blank), 0, this.blank, 0, 
                232);

            for (var i = 0; i < 930; ++i) {
                this.slotsUnlocked[i] = ((JS.Uint8ArrayHelper.Empty$1(this.boxKey1, i * 232, 232) ? 1 : 0) & 0xFF);
            }
        }
    };
    $t.ctor$1.prototype = $p;
});
KeySAVCore.SaveReaderDecrypted = $d.declare("KeySAVCore.SaveReaderDecrypted", System.Object, 0, $asm, function($t, $p) {
    $t.$intfs = [KeySAVCore.ISaveReader];
    $t.cctor = function() {
        $t.orasOffset = 208896;
        $t.xyOffset = 140800;
        $t.xyRamsavOffset = 126776;
        $t.orasRamsavOffset = 194452;
    };
    $t.$ator = function() {
        this.sav = null;
        this.offset = 0;
    };
    $p.get_KeyName = function SaveReaderDecrypted_get_KeyName() {
        return "Decrypted. No Key needed";
    };
    $p.get_UnlockedSlots = function SaveReaderDecrypted_get_UnlockedSlots() {
        return 930;
    };
    $t.ctor = function SaveReaderDecrypted(file, type) {
        $t.$baseType.ctor.call(this);
        this.sav = file;
        switch (type) {
            case "XY":
                this.offset = 140800 /* SaveReaderDecrypted.xyOffset */;
                break;
            case "ORAS":
                this.offset = 208896 /* SaveReaderDecrypted.orasOffset */;
                break;
            case "YABD":
                this.offset = 4;
                var ekx = file.subarray(4, 236);
                if (!KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx)))
                    this.offset = 8;
                break;
            case "PCDATA":
                this.offset = 0;
                break;
            case "XYRAM":
                this.offset = 126776 /* SaveReaderDecrypted.xyRamsavOffset */;
                break;
            case "ORASRAM":
                this.offset = 194452 /* SaveReaderDecrypted.orasRamsavOffset */;
                break;
        }
    };
    $t.ctor.prototype = $p;
    $p.scanSlots = function SaveReaderDecrypted_scanSlots() {};
    $p.scanSlots$1 = function SaveReaderDecrypted_scanSlots(pos) {};
    $p.scanSlots$2 = function SaveReaderDecrypted_scanSlots(from, to) {};
    $p.getPkx = function SaveReaderDecrypted_getPkx(pos) {
        var pkxOffset = ((this.offset + pos * 232) | 0);
        var pkx = this.sav.subarray(pkxOffset, pkxOffset + 232);
        if (JS.Uint8ArrayHelper.Empty(pkx))
            return null;
        pkx = KeySAVCore.Structures.PKX.decrypt(pkx);
        if (KeySAVCore.Structures.PKX.verifyCHK(pkx) && (pkx[8] | pkx[9]) != 0) {
            return new KeySAVCore.Structures.PKX.ctor$1(pkx, ((pos / 30 | 0) & 0xFF), ((pos % 30) & 0xFF), 
                false);

        }
        return null;
    };
    $p.KeySAVCore$ISaveReader$get_KeyName = $p.get_KeyName;
    $p.KeySAVCore$ISaveReader$get_UnlockedSlots = $p.get_UnlockedSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$2 = $p.scanSlots$2;
    $p.KeySAVCore$ISaveReader$scanSlots = $p.scanSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$1 = $p.scanSlots$1;
    $p.KeySAVCore$ISaveReader$getPkx = $p.getPkx;
});
KeySAVCore.SaveReaderEncrypted = $d.declare("KeySAVCore.SaveReaderEncrypted", System.Object, 0, $asm, function($t, $p) {
    $t.$intfs = [KeySAVCore.ISaveReader];
    $t.cctor = function() {
        $t.zeros = null;
        $t.ezeros = null;
        $t.zeros = new Uint8Array(232);
        $t.ezeros = KeySAVCore.Structures.PKX.encrypt($t.zeros);
    };
    $t.$ator = function() {
        this.sav = null;
        this.key = new KeySAVCore.Structures.SaveKey.ctor();
        this.activeSlot = 0;
        this._KeyName = null;
    };
    $p.get_KeyName = function SaveReaderEncrypted_get_KeyName() {
        return this._KeyName;
    };
    $p.get_UnlockedSlots = function SaveReaderEncrypted_get_UnlockedSlots() {
        var res = 0;
        for (var i = 0; i < this.key.slotsUnlocked.length; ++i) {
            if (this.key.slotsUnlocked[i] != 0)
                ++res;
        }
        return res;
    };
    $t.ctor = function SaveReaderEncrypted(file, key_) {
        $t.$baseType.ctor.call(this);
        this.sav = file;

        this.key = new KeySAVCore.Structures.SaveKey.ctor$1(key_);

        this._KeyName = System.IO.Path.GetFileName(this._KeyName);

        if (this.key.slot1Flag == KeySAVCore.BitConverter.ToUInt32(this.sav, 360))
            this.activeSlot = 0;
        else
            this.activeSlot = 1;

        KeySAVCore.Utility.XorInPlace(this.sav, (this.key.boxOffset | 0) - 520192, this.key.slot1Key, 
            0, 215760 /* 232*30*31 */);
    };
    $t.ctor.prototype = $p;
    $t.ctor$1 = function SaveReaderEncrypted(file, key) {
        $t.$baseType.ctor.call(this);
        this.sav = file;

        this.key = key;

        this._KeyName = "";

        if (key.slot1Flag == KeySAVCore.BitConverter.ToUInt32(this.sav, 360))
            this.activeSlot = 0;
        else
            this.activeSlot = 1;

        KeySAVCore.Utility.XorInPlace(this.sav, (key.boxOffset | 0) - 520192, key.slot1Key, 0, 215760 /* 232*30*31 */);
    };
    $t.ctor$1.prototype = $p;
    $p.scanSlots = function SaveReaderEncrypted_scanSlots() {
        var ghost = {};
        for (var i = 0; i < 930 /* 30*31 */; ++i) {
            this.getPkxRaw(i, 0, ghost);
            this.getPkxRaw(i, 1, ghost);
        }
    };
    $p.scanSlots$1 = function SaveReaderEncrypted_scanSlots(pos) {
        var ghost = {};
        this.getPkxRaw(pos, 0, ghost);
        this.getPkxRaw(pos, 1, ghost);
    };
    $p.scanSlots$2 = function SaveReaderEncrypted_scanSlots(start, end) {
        for (var i = start; i <= end; ++i) {
            var ghost = {};
            this.getPkxRaw(i, 0, ghost);
            this.getPkxRaw(i, 1, ghost);
        }
    };
    $p.getPkx = function SaveReaderEncrypted_getPkx(pos) {
        var ghost = {};
        var data = this.getPkxRaw(pos, this.activeSlot, ghost);
        if (data == null || (data[8] | data[9]) == 0)
            return null;
        return new KeySAVCore.Structures.PKX.ctor$1(data, ((pos / 30 | 0) & 0xFF), ((pos % 30) & 0xFF), 
            ghost.value);
    };
    $p.getPkxRaw = function SaveReaderEncrypted_getPkxRaw(pos, slot, ghost) {
        // TODO refactor moar
        // Auto updates the keystream when it dumps important data!
        var ekx = new Uint8Array(232);

        ghost.value = true;

        var keyOffset = pos * 232;
        var savOffset = ((keyOffset + this.key.boxOffset - (1 - slot) * 520192) | 0);

        if (KeySAVCore.Utility.SequenceEqual$1($t.zeros, this.key.boxKey1, keyOffset) && KeySAVCore.Utility.SequenceEqual$1($t.zeros, 
            this.key.boxKey2, keyOffset))
            return null;
        else
            if (KeySAVCore.Utility.SequenceEqual$1($t.zeros, this.key.boxKey1, keyOffset)) {
                // Key2 is confirmed to dump the data.
                ekx = KeySAVCore.Utility.xor$2(this.key.boxKey2, keyOffset, this.sav, savOffset, 232);
                ghost.value = false;
                this.key.slotsUnlocked[slot] = 1;
            }
            else
                if (KeySAVCore.Utility.SequenceEqual$1($t.zeros, this.key.boxKey2, keyOffset)) {
                    // Haven't dumped from this slot yet.
                    if (KeySAVCore.Utility.SequenceEqual$2(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                        232)) {
                        // Slot hasn't changed.
                        return null;
                    }
                    else {
                        // Try and decrypt the data...
                        ekx = KeySAVCore.Utility.xor$2(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                            232);
                        if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx))) {
                            // Data has been dumped!
                            // Fill keystream data with our log.
                            JS.Uint8ArrayHelper.Copy(this.sav, savOffset, this.key.boxKey2, keyOffset, 
                                232);
                        }
                        else {
                            // Try xoring with the empty data.
                            if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                this.key.blank)))) {
                                ekx = KeySAVCore.Utility.xor(ekx, this.key.blank);
                                KeySAVCore.Utility.xor$3(this.key.blank, 0, this.sav, savOffset, this.key.boxKey2, 
                                    keyOffset, 232);
                            }
                            else
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                    $t.ezeros)))) {
                                    ekx = KeySAVCore.Utility.xor(ekx, $t.ezeros);
                                    KeySAVCore.Utility.xor$3($t.ezeros, 0, this.sav, savOffset, this.key.boxKey2, 
                                        keyOffset, 232);
                                }
                                else
                                    return null; // Not a failed decryption; we just haven't seen new data here yet.
                        }
                    }
                }
                else {
                    // We've dumped data at least once.
                    if (KeySAVCore.Utility.SequenceEqual$2(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                        232) || KeySAVCore.Utility.SequenceEqual$2(this.key.boxKey1, keyOffset, KeySAVCore.Utility.xor$1(this.key.blank, 
                        this.sav, savOffset), 0, 232) || KeySAVCore.Utility.SequenceEqual$2(this.key.boxKey1, 
                        keyOffset, KeySAVCore.Utility.xor$1($t.ezeros, this.sav, savOffset), 0, 232)) {
                        // Data is back to break state, but we can still dump with the other key.
                        ekx = KeySAVCore.Utility.xor$2(this.key.boxKey2, keyOffset, this.sav, savOffset, 
                            232);
                        if (!KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx))) {
                            if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                this.key.blank)))) {
                                ekx = KeySAVCore.Utility.xor(ekx, this.key.blank);
                                KeySAVCore.Utility.xor$3(this.key.blank, 0, this.key.boxKey2, keyOffset, 
                                    this.key.boxKey2, keyOffset, 232);
                            }
                            else
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                    $t.ezeros)))) {
                                    // Key1 decrypts our data after we remove encrypted zeros.
                                    // Copy Key1 to Key2, then zero out Key1.
                                    ekx = KeySAVCore.Utility.xor(ekx, $t.ezeros);
                                    KeySAVCore.Utility.xor$3($t.ezeros, 0, this.key.boxKey2, keyOffset, 
                                        this.key.boxKey2, keyOffset, 232);
                                }
                                else
                                    return null; // Decryption Error
                        }
                    }
                    else
                        if (KeySAVCore.Utility.SequenceEqual$2(this.key.boxKey2, keyOffset, this.sav, 
                            savOffset, 232) || KeySAVCore.Utility.SequenceEqual$2(this.key.boxKey2, keyOffset, 
                            KeySAVCore.Utility.xor$1(this.key.blank, this.sav, savOffset), 0, 232) || KeySAVCore.Utility.SequenceEqual$2(this.key.boxKey2, 
                            keyOffset, KeySAVCore.Utility.xor$1($t.ezeros, this.sav, savOffset), 0, 232)) {
                            // Data is changed only once to a dumpable, but we can still dump with the other key.
                            ekx = KeySAVCore.Utility.xor$2(this.key.boxKey1, keyOffset, this.sav, savOffset, 
                                232);
                            if (!KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(ekx))) {
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                    this.key.blank)))) {
                                    ekx = KeySAVCore.Utility.xor(ekx, this.key.blank);
                                    KeySAVCore.Utility.xor$3(this.key.blank, 0, this.key.boxKey1, keyOffset, 
                                        this.key.boxKey1, keyOffset, 232);
                                }
                                else
                                    if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(ekx, 
                                        $t.ezeros)))) {
                                        ekx = KeySAVCore.Utility.xor(ekx, $t.ezeros);
                                        KeySAVCore.Utility.xor$3($t.ezeros, 0, this.key.boxKey1, keyOffset, 
                                            this.key.boxKey1, keyOffset, 232);
                                    }
                                    else
                                        return null; // Decryption Error
                            }
                        }
                        else {
                            // Data has been observed to change twice! We can get our exact keystream now!
                            // Either Key1 or Key2 or Save is empty. Whichever one decrypts properly is the empty data.
                            // Oh boy... here we go...
                            ghost.value = false;
                            this.key.slotsUnlocked[slot] = 1;
                            var keydata1, keydata2 = false;
                            var data1 = KeySAVCore.Utility.xor$2(this.sav, savOffset, this.key.boxKey1, 
                                keyOffset, 232);
                            var data2 = KeySAVCore.Utility.xor$2(this.sav, savOffset, this.key.boxKey2, 
                                keyOffset, 232);

                            keydata1 = (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(data1)) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data1, 
                                $t.ezeros))) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data1, 
                                this.key.blank))));
                            keydata2 = (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(data2)) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data2, 
                                $t.ezeros))) || KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(data2, 
                                this.key.blank))));

                            var emptyKey, emptyKeyData;
                            var emptyOffset;

                            if (keydata1 && keydata2) {
                                // Save file is currently empty...
                                // Copy key data from save file if it decrypts with Key1 data properly.
                                emptyKey = this.sav;
                                emptyOffset = savOffset;
                                emptyKeyData = data1;
                            }
                            else
                                if (keydata1) { // Key 1 is empty
                                    emptyKey = this.key.boxKey1;
                                    emptyOffset = keyOffset;
                                    emptyKeyData = data1;
                                }
                                else
                                    if (keydata2) { // Key 2 is emtpy
                                        emptyKey = this.key.boxKey2;
                                        emptyOffset = keyOffset;
                                        emptyKeyData = data2;
                                    }
                                    else
                                        return null; // All three are occupied

                            if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(emptyKeyData))) {
                                // No modifications necessary.
                                ekx = emptyKeyData;
                                JS.Uint8ArrayHelper.Copy(emptyKey, emptyOffset, this.key.boxKey2, keyOffset, 
                                    232);
                                JS.Uint8ArrayHelper.Copy($t.zeros, 0, this.key.boxKey1, keyOffset, 232);
                            }
                            else
                                if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(emptyKeyData, 
                                    $t.ezeros)))) {
                                    ekx = $t.ezeros;
                                    KeySAVCore.Utility.xor$3($t.ezeros, 0, emptyKey, emptyOffset, this.key.boxKey2, 
                                        keyOffset, 232);
                                    JS.Uint8ArrayHelper.Copy($t.zeros, 0, this.key.boxKey1, keyOffset, 
                                        232);
                                }
                                else
                                    if (KeySAVCore.Structures.PKX.verifyCHK(KeySAVCore.Structures.PKX.decrypt(KeySAVCore.Utility.xor(emptyKeyData, 
                                        this.key.blank)))) {
                                        ekx = $t.ezeros;
                                        KeySAVCore.Utility.xor$3(this.key.blank, 0, emptyKey, emptyOffset, 
                                            this.key.boxKey2, keyOffset, 232);
                                        JS.Uint8ArrayHelper.Copy($t.zeros, 0, this.key.boxKey1, keyOffset, 
                                            232);
                                    }
                        }
                }
        var pkx = KeySAVCore.Structures.PKX.decrypt(ekx);
        if (KeySAVCore.Structures.PKX.verifyCHK(pkx)) {
            return pkx;
        }
        else
            return null; // Slot Decryption error?!
    };
    $p.KeySAVCore$ISaveReader$get_KeyName = $p.get_KeyName;
    $p.KeySAVCore$ISaveReader$get_UnlockedSlots = $p.get_UnlockedSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$2 = $p.scanSlots$2;
    $p.KeySAVCore$ISaveReader$scanSlots = $p.scanSlots;
    $p.KeySAVCore$ISaveReader$scanSlots$1 = $p.scanSlots$1;
    $p.KeySAVCore$ISaveReader$getPkx = $p.getPkx;
});
KeySAVCore.Utility = $d.declare("KeySAVCore.Utility", System.Object, 0, $asm, function($t, $p) {
    $t.xor = function Utility_xor(one, two) {
        if (one.length != two.length)
            return null;
        var length = one.length;
        var res = new Uint8Array(length);
        for (var i = 0; i < length; ++i) {
            res[i] = ((one[i] ^ two[i]) & 0xFF);
        }
        return res;
    };
    $t.xor$1 = function Utility_xor(first, second, secondoffset) {
        return $t.xor$2(first, 0, second, secondoffset, first.length);
    };
    $t.xor$2 = function Utility_xor(first, firstOffset, second, secondOffset, length) {
        var res = new Uint8Array(length);
        for (var i = 0; i < length; ++i) {
            res[i] = ((first[firstOffset + i] ^ second[secondOffset + i]) & 0xFF);
        }
        return res;
    };
    $t.xor$3 = function Utility_xor(first, firstOffset, second, secondOffset, target, targetOffset, length) {
        for (var i = 0; i < length; ++i) {
            target[i + targetOffset] = ((first[i + firstOffset] ^ second[i + secondOffset]) & 0xFF);
        }
    };
    $t.XorInPlace = function Utility_XorInPlace(self, offset, other, otherOffset, length) {
        for (var i = 0; i < length; ++i) {
            self[((i + offset) | 0)] = ((self[((i + offset) | 0)] ^ other[((i + otherOffset) | 0)]) & 0xFF);
        }
    };
    $t.SequenceEqual$1 = function Utility_SequenceEqual(self, other, offset) {
        for (var i = 0; i < self.length; ++i) {
            if (self[i] != other[offset + i])
                return false;
        }
        return true;
    };
    $t.SequenceEqual$2 = function Utility_SequenceEqual(one, oneOffset, two, twoOffset, length) {
        for (var i = 0; i < length; ++i) {
            if (one[i + oneOffset] != two[i + twoOffset])
                return false;
        }
        return true;
    };
    $t.SequenceEqual = function Utility_SequenceEqual(self, other) {
        for (var i = 0; i < self.length; ++i) {
            if (self[i] != other[i])
                return false;
        }
        return true;
    };
    $t.Empty = function Utility_Empty(array) {
        return System.Linq.Enumerable.All(System.Byte, array, $d.delegate(function(e) {
            return e == 0;
        }, this));
    };
    $t.Empty$1 = function Utility_Empty(array, offset, length) {
        for (var i = offset; i < offset + length; ++i) {
            if (array[i] != 0)
                return false;
        }
        return true;
    };
    $t.TrimCString = function Utility_TrimCString(str) {
        var index = str.IndexOf(0);
        if (index < 0)
            return str;

        return str.Substring$1(0, index);
    };
    $t.CleanFileName = function Utility_CleanFileName(fileName) {
        return System.Linq.Enumerable.Aggregate$1(System.Char, String, System.IO.Path.GetInvalidFileNameChars(), 
            fileName, $d.delegate(function(current, c) {
                return current.Replace$1(String.fromCharCode(c), String.Empty);
            }, this));
    };
    $t.Switch = function Utility_Switch(T, one, two) {
        var tmp = one.value;
        one.value = two.value;
        two.value = tmp;
    };
});
return $asm;
})();
//# sourceMappingURL=KeySAVCoreJS.js.map
